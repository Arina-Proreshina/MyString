#ifndef MYSTRING_H
#define MYSTRING_H

#include <stddef.h>
#include <stdio.h>

/**
 * @brief Вычисляет длину строки.
 *
 * @details
 * Функция возвращает количество символов в строке, не включая нулевой символ '\0'.
 *
 * @param str Указатель на строку, длину которой нужно вычислить.
 * @return Длина строки.
 */
size_t myStrlen(const char* str);

/**
 * @brief Копирует одну строку в другую.
 *
 * @details
 * Функция копирует содержимое строки `src` в строку `dest`, включая нулевой символ '\0'.
 *
 * @param dest Указатель на строку, в которую будет скопирована строка `src`.
 * @param src Указатель на строку, которую нужно скопировать.
 * @note Если размер буфера `dest` меньше буфера `src`, то поведение не определено.
 */
char* myStrcpy(char* dst, const char* src);

/**
 * @brief Копирует до n символов из строки src в строку dst.
 *
 * @details
 * Функция копирует максимум n символов из строки `src` в строку `dst`.
 * Если длина строки `src` меньше `n`, то в конце строки `dst` будут добавлены нулевые символы.
 *
 * @param dst Указатель на строку, в которую будет скопирована строка.
 * @param src Указатель на строку, которую нужно скопировать.
 * @param n Максимальное количество символов для копирования.
 * @return Указатель на строку `dst`.
 * @note Если строка `dst` имеет недостаточный размер, то поведение не определено.
 */
char* myStrncpy(char *dst, const char *src, size_t n);

/**
 * @brief Конкатенирует одну строку с другой.
 *
 * @details
 * Функция добавляет строку `src` в конец строки `dest`. В результате `dest` будет
 * содержать обе строки, соединенные вместе.
 *
 * @param dest Указатель на строку, к которой будет добавлена строка `src`.
 * @param src Указатель на строку, которую нужно добавить к `dest`.
 * @note Если размер буфера `dest` недостаточен для размещения строки `src`, то поведение не определено.
 */
char* myStrconn(char* dst, const char* src);

/**
 * @brief Ищет первое вхождение символа в строке.
 *
 * @details
 * Функция ищет первое вхождение символа `c` в строке `str`. Возвращает указатель
 * на первый найденный символ, либо NULL, если символ не найден.
 *
 * @param str Указатель на строку, в которой выполняется поиск.
 * @param c Символ для поиска.
 * @return Указатель на первое вхождение символа или NULL, если символ не найден.
 */
char* myStrchr(const char* str, int c);

/**
 * @brief Разбивает строку на подстроки, используя разделители.
 *
 * @details
 * Функция разделяет строку `str` на подстроки, используя символы-разделители из строки `delim`.
 * При последующих вызовах этой функции необходимо передавать `NULL` вместо `str` для продолжения разделения.
 *
 * @param str Указатель на строку для разделения (при первом вызове) или `NULL` (для продолжения).
 * @param delim Указатель на строку, содержащую разделители.
 * @return Указатель на текущую подстроку или `NULL`, если подстроки больше не найдены.
 */
char* myStrtok(char* str, const char* delim);

/**
 * @brief Сравнивает две строки.
 *
 * @details
 * Функция сравнивает строки `str1` и `str2` посимвольно. Возвращает 0, если строки равны,
 * отрицательное значение, если `str1` меньше `str2`, и положительное значение, если `str1` больше `str2`.
 *
 * @param str1 Указатель на первую строку.
 * @param str2 Указатель на вторую строку.
 * @return 0, если строки равны; отрицательное значение, если `str1` меньше `str2`;
 * положительное значение, если `str1` больше `str2`.
 * @note Функция чувствительна к регистру и не пропускает пробелы.
 */
int myStrcmp(const char* str1, const char* str2);

/**
 * @brief Выводит строку на стандартный вывод.
 *
 * @details
 * Функция выводит строку `str` на стандартный вывод и добавляет символ новой строки `\n` в конце.
 *
 * @param str Указатель на строку для вывода.
 * @return 0 при успешном завершении, или EOF в случае ошибки.
 */
int myPuts(const char *str);

/**
 * @brief Обрезает строку до первого вхождения символа.
 *
 * @details
 * Функция обрезает строку `str`, устанавливая нулевой символ '\0' на место первого вхождения символа `c`.
 *
 * @param str Указатель на строку для обрезки.
 * @param c Символ, на месте которого будет установлена обрезка.
 * @return Указатель на модифицированную строку.
 */
char* myStrcut(char *str, int c);

/**
 * @brief Обрезает строку до первых n символов.
 *
 * @details
 * Функция обрезает строку `str`, оставляя в ней только первые `n` символов.
 *
 * @param str Указатель на строку для обрезки.
 * @param n Количество символов для сохранения.
 * @return Указатель на модифицированную строку.
 */
char* myStrncut(char *str, size_t n);

/**
 * @brief Читает строку из файла.
 *
 * @details
 * Функция читает строку из потока `stream` до конца строки или до символа новой строки.
 * Чтение выполняется максимум до `n-1` символов, после чего добавляется символ конца строки.
 *
 * @param str Указатель на буфер для хранения строки.
 * @param n Максимальное количество символов для чтения.
 * @param stream Указатель на файл или поток для чтения.
 * @return Указатель на строку, или `NULL`, если достигнут конец файла или произошла ошибка.
 */
char* myFgets(char *str, int n, FILE *stream);

/**
 * @brief Дублирует строку.
 *
 * @details
 * Функция создает динамическую копию строки `src`. Память для копии выделяется с помощью `malloc()`,
 * и должна быть освобождена с помощью `free()`.
 *
 * @param src Указатель на строку для копирования.
 * @return Указатель на новую строку, или `NULL` в случае ошибки выделения памяти.
 */
char* myStrdup(const char *src);

/**
 * @brief Возвращает длину строки.
 *
 * @details
 * Функция вычисляет длину строки, но не более чем `max_len` символов. Если строка короче,
 * возвращает её фактическую длину.
 *
 * @param str Указатель на строку.
 * @param max_len Максимальное количество символов для подсчета.
 * @return Длина строки, ограниченная `max_len`.
 */
size_t myGetlen(const char *str, size_t max_len);

#endif // MYSTRING_H
